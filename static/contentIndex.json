{"codes/codes/http_socket/client.py":{"title":"client.py","links":[],"tags":[],"content":"import socket\nimport struct\nimport time\nimport pickle  # Import pickle pro serializaci dat\n \nSERVER_ADR = (&#039;localhost&#039;, 12345)\n \ndef start_client(message):\n    # Vytvoření socketu pro připojení k serveru\n    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    client_socket.connect(SERVER_ADR)\n \n    try:\n        # Serializace zprávy pomocí pickle\n        serialized_message = pickle.dumps(message)\n \n        # Odeslání délky zprávy (v tomto případě je to délka ve formátu unsigned int)\n        message_length = len(serialized_message)\n        client_socket.sendall(struct.pack(&quot;I&quot;, message_length))  # Odeslání délky jako unsigned int (4 byty)\n \n        # Odeslání samotné zprávy\n        client_socket.sendall(serialized_message)\n \n        # Přijmeme odpověď od serveru\n        response_length = struct.unpack(&quot;I&quot;, client_socket.recv(4))[0]  # Nejprve přijmeme délku odpovědi\n        response = pickle.loads(client_socket.recv(response_length))  # Poté odpověď samotnou\n        print(f&quot;Server odpověděl: {response}&quot;)\n \n    except Exception as e:\n        print(f&quot;Chyba při komunikaci: {e}&quot;)\n    finally:\n        client_socket.close()\n \nif __name__ == &quot;__main__&quot;:\n    # Zprávy mohou být nyní jakýkoliv Python objekt\n    start_client((&quot;Petr&quot;, &quot;Novák&quot;, 45))  # Posíláme n-tici\n    start_client((&quot;Jana&quot;, &quot;Nováková&quot;,33))  # Posíláme další n-tici\n    time.sleep(2)\n    start_client(&quot;!STOP&quot;)  # Posíláme příkaz k zastavení serveru"},"codes/codes/http_socket/server.py":{"title":"server.py","links":[],"tags":[],"content":"import socket\nimport threading\nimport struct\nimport time\nimport pickle  # Přidání knihovny pickle\nfrom typing import Tuple\n \n# Jednoduchá databáze\ndatabase = {1: [&quot;Karel&quot;, &quot;Novy&quot;, 5], 2: [&quot;Marek&quot;, &quot;Modry&quot;, 99]}\n \n# Globální proměnná pro kontrolu, zda má server běžet\nserver_running = True\n \ndef print_database():\n    print(&quot;\\n&quot;)\n    print(f&quot;{&#039;ID&#039;:&lt;5} | {&#039;Name&#039;:&lt;10} | {&#039;Lastname&#039;:&lt;10} | {&#039;Age&#039;:&lt;5}&quot;)\n    print(&quot;-&quot; * 39)\n \n    for key, value in database.items():\n        print(f&quot;{key:&lt;5} | {value[0]:&lt;10} | {value[1]:&lt;10} | {value[2]:&lt;5}&quot;)\n    print(&quot;\\n&quot;)\n \n# Funkce pro obsluhu každého klienta\ndef handle_client(client_socket: socket.socket, client_address: Tuple[str, int]) -&gt; None:\n    global server_running\n    \n    try:\n        # Přijme 4 byty, které určují velikost dat (formát je &quot;I&quot;, což je unsigned int)\n        data_length = struct.unpack(&quot;I&quot;, client_socket.recv(4))[0]  # Očekáváme velikost zprávy jako unsigned int\n        print(f&quot;Čekám {data_length} bytů od {client_address}&quot;)\n \n        # Přijme požadovaná data (data_length bytů)\n        data = client_socket.recv(data_length)\n        # Deserializace dat pomocí pickle\n        msg = pickle.loads(data)\n        print(f&quot;Přijato: {msg}&quot;)\n \n        # Odeslání odpovědi zpět klientovi\n        response = pickle.dumps(&quot;Data prijata!&quot;)\n        response_length = struct.pack(&quot;I&quot;, len(response))\n        client_socket.sendall(response_length + response)\n \n        # Zpracování zprávy\n        if msg == &#039;!STOP&#039;:\n            print(&quot;Příkaz pro zastavení serveru přijat.&quot;)\n            server_running = False\n        elif isinstance(msg, tuple) and len(msg) == 3:\n            # Přidání n-tice do databáze\n            database[len(database) + 1] = list(msg)\n \n    except Exception as e:\n        print(f&quot;Chyba při zpracování klienta {client_address}: {e}&quot;)\n    finally:\n        client_socket.close()\n \n# Server\ndef start_server() -&gt; None:\n    global server_running\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind((&#039;localhost&#039;, 12345))\n    server_socket.listen()\n    print(&quot;Server běží na portu 12345...&quot;)\n    print_database()\n \n    while server_running:\n        try:\n            # Zkontrolujeme, zda je nějaký klient připraven na připojení\n            client_socket, client_address = server_socket.accept()\n            print(f&quot;Připojen klient: {client_address}&quot;)\n \n            # Vytvoření vlákna pro obsluhu klienta\n            client_thread = threading.Thread(target=handle_client, args=(client_socket, client_address))\n            client_thread.start()\n \n        except BlockingIOError:\n            # Pokud žádný klient není připraven, pokračujeme dál\n            pass\n \n        # Zkontrolujeme, zda má server běžet nebo zastavit\n        if not server_running:\n            print(&quot;Server je zastaven.&quot;)\n            break\n \n        time.sleep(1)  # Na chvíli spíme\n \n    # Zastavení serveru\n    print(&quot;Server byl zastaven.&quot;)\n    server_socket.close()\n    print_database()\n \nif __name__ == &quot;__main__&quot;:\n    start_server()"},"codes/codes/http_socket/server_http.py":{"title":"server_http.py","links":[],"tags":[],"content":"from http.server import HTTPServer, BaseHTTPRequestHandler\n \n \n# Jednoduchá databáze\ndatabase = {1: [&quot;Karel&quot;, &quot;Novy&quot;], 2: [&quot;Marek&quot;, &quot;Modry&quot;]}\n \ndef print_database() -&gt; None:\n    print(&quot;\\n&quot;)\n    print(f&quot;{&#039;ID&#039;:&lt;5} | {&#039;Name&#039;:&lt;10} | {&#039;Lastname&#039;:&lt;10}&quot;)\n    print(&quot;-&quot; * 31)\n \n    for key, value in database.items():\n        print(f&quot;{key:&lt;5} | {value[0]:&lt;10} | {value[1]:&lt;10}&quot;)\n    print(&quot;\\n&quot;)\n \n# Vlastní třída pro zpracování HTTP požadavků\nclass MyHandler(BaseHTTPRequestHandler):\n    def do_GET(self) -&gt; None:\n \n        self.send_response(200)\n        self.send_header(&quot;Content-type&quot;, &quot;text/html&quot;)\n        self.end_headers()\n \n        # Zpracování požadavků na zobrazení databáze\n        self.wfile.write(b&quot;&lt;h1&gt;Database:&lt;/h1&gt;&quot;)\n        self.wfile.write(b&quot;&lt;table border=&#039;1&#039;&gt;&lt;tr&gt;&lt;th&gt;ID&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Lastname&lt;/th&gt;&lt;/tr&gt;&quot;)\n        for key, value in database.items():\n            self.wfile.write(f&quot;&lt;tr&gt;&lt;td&gt;{key}&lt;/td&gt;&lt;td&gt;{value[0]}&lt;/td&gt;&lt;td&gt;{value[1]}&lt;/td&gt;&lt;/tr&gt;&quot;.encode(&#039;utf-8&#039;))\n        self.wfile.write(b&quot;&lt;/table&gt;&quot;)\n \n    def do_POST(self) -&gt; None:\n \n        # Získání délky těla požadavku (velikost dat)\n        content_length = int(self.headers[&#039;Content-Length&#039;])\n        post_data = self.rfile.read(content_length)\n \n        # Decoding a zpracování přijatých dat\n        msg = post_data.decode(&#039;utf-8&#039;)\n        print(f&quot;Přijato: {msg}&quot;)\n \n        self.send_response(200)\n        self.send_header(&quot;Content-type&quot;, &quot;text/html&quot;)\n        self.end_headers()\n        \n        #pro jednoduchost predpokladame ze zprava ma spravny format\n        if msg not in [f&quot;{value[0]} {value[1]}&quot; for value in database.values()]:\n                new_id = len(database) + 1\n                first_name, last_name = msg.split(&quot; &quot;, 1)\n                database[new_id] = [first_name, last_name]\n                self.wfile.write(b&quot;Data byla ulozena.&quot;)\n        else:\n            self.wfile.write(b&quot;Jmeno je jiz v databazi.&quot;)\n \n# Funkce pro spuštění serveru\ndef start_server():\n    global server_running\n    \n    # Tisk databáze\n    print_database()\n \n    # Vytvoření HTTP serveru na localhostu a portu 8080\n    server = HTTPServer((&#039;localhost&#039;, 8080), MyHandler)\n    print(&quot;Server běží na portu 8080...&quot;)\n    server.serve_forever()\n \n# Spuštění serveru\nif __name__ == &quot;__main__&quot;:\n    start_server()```"},"codes/codes/rabbitmq_examples/RabbitMQ_consumer.py":{"title":"RabbitMQ_consumer.py","links":[],"tags":[],"content":"import pika\n \ndef callback(ch, method, properties, body):\n    print(f&quot; [x] Přijatá zpráva: {body}&quot;)\n \n# Navázání spojení s RabbitMQ serverem\nconnection = pika.BlockingConnection(pika.ConnectionParameters(&#039;localhost&#039;))\nchannel = connection.channel()\n \n# Deklarace fronty\nchannel.queue_declare(queue=&#039;hello&#039;)\n \n# Přihlášení ke zprávám z fronty\nchannel.basic_consume(queue=&#039;hello&#039;, on_message_callback=callback, auto_ack=True)\n \nprint(&#039; [*] Čekám na zprávy. Pro ukončení stiskněte CTRL+C&#039;)\nchannel.start_consuming()```"},"codes/codes/rabbitmq_examples/RabbitMQ_fanout.py":{"title":"RabbitMQ_fanout.py","links":[],"tags":[],"content":"import pika\n \n# Navázání spojení s RabbitMQ serverem\nconnection = pika.BlockingConnection(pika.ConnectionParameters(&#039;localhost&#039;))\nchannel = connection.channel()\n \n# Deklarace výměníku typu fanout\nchannel.exchange_declare(exchange=&#039;logs&#039;, exchange_type=&#039;fanout&#039;)\n \n# Deklarace fronty\nresult = channel.queue_declare(&#039;&#039;, exclusive=True)\nqueue_name = result.method.queue\n \n# Přiřazení fronty k výměníku\nchannel.queue_bind(exchange=&#039;logs&#039;, queue=queue_name)\n \n# Callback pro zpracování přijatých zpráv\ndef callback(ch, method, properties, body):\n    print(f&quot; [x] Přijatý log: {body}&quot;)\n \n# Přihlášení ke zprávám\nchannel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=True)\n \nprint(&#039; [*] Čekám na logy. Pro ukončení stiskněte CTRL+C&#039;)\nchannel.start_consuming()```"},"codes/codes/rabbitmq_examples/RabbitMQ_producent.py":{"title":"RabbitMQ_producent.py","links":[],"tags":[],"content":"import pika\n \n# Navázání spojení s RabbitMQ serverem\nconnection = pika.BlockingConnection(pika.ConnectionParameters(&#039;localhost&#039;))\nchannel = connection.channel()\n \n# Deklarace fronty\nchannel.queue_declare(queue=&#039;hello&#039;)\n \n# Odeslání zprávy\nchannel.basic_publish(exchange=&#039;&#039;,\n                      routing_key=&#039;hello&#039;,\n                      body=&#039;Hello, RabbitMQ!&#039;)\n \nprint(&quot; [x] Zpráva &#039;Hello, RabbitMQ!&#039; byla odeslána.&quot;)\n \n# Uzavření spojení\nconnection.close()```"},"codes/codes/rabbitmq_examples/RabbitMQ_realtime.py":{"title":"RabbitMQ_realtime.py","links":[],"tags":[],"content":"import pika\n \n# Navázání spojení s RabbitMQ serverem\nconnection = pika.BlockingConnection(pika.ConnectionParameters(&#039;localhost&#039;))\nchannel = connection.channel()\n \n# Deklarace výměníku typu fanout pro logy\nchannel.exchange_declare(exchange=&#039;logs&#039;, exchange_type=&#039;fanout&#039;)\n \n# Deklarace fronty pro příjem logů\nresult = channel.queue_declare(&#039;&#039;, exclusive=True)\nqueue_name = result.method.queue\n \n# Přiřazení fronty k výměníku\nchannel.queue_bind(exchange=&#039;logs&#039;, queue=queue_name)\n \n# Callback pro zpracování logů\ndef callback(ch, method, properties, body):\n    print(f&quot; [x] Přijatý log: {body}&quot;)\n \n# Přihlášení ke zprávám\nchannel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=True)\n \nprint(&#039; [*] Čekám na logy. Pro ukončení stiskněte CTRL+C&#039;)\nchannel.start_consuming()```"},"codes/codes/rabbitmq_examples/RabbitMQ_reliability.py":{"title":"RabbitMQ_reliability.py","links":[],"tags":[],"content":"import pika\n \n# Navázání spojení s RabbitMQ serverem\nconnection = pika.BlockingConnection(pika.ConnectionParameters(&#039;localhost&#039;))\nchannel = connection.channel()\n \n# Deklarace fronty s povolením trvalosti (durable)\nchannel.queue_declare(queue=&#039;task_queue&#039;, durable=True)\n \n# Publikování zprávy s potvrzením\nchannel.basic_publish(exchange=&#039;&#039;,\n                      routing_key=&#039;task_queue&#039;,\n                      body=&#039;Úkol 1&#039;,\n                      properties=pika.BasicProperties(\n                          delivery_mode=2,  # Zpráva je trvalá\n                      ))\n \nprint(&quot; [x] Zpráva &#039;Úkol 1&#039; byla odeslána.&quot;)\n \n# Uzavření spojení\nconnection.close()```"},"codes/codes/synchronization_tools/asyncio.py":{"title":"asyncio.py","links":[],"tags":[],"content":"import asyncio\n \n# Definování korutiny\nasync def download_file(id):\n    print(&quot;Stahuji soubor {}&quot;.format(id))\n    # Simulace čekání na stažení nějakého souboru\n    await asyncio.sleep(1)\n    print(&quot;Soubor {} byl stažen.&quot;.format(id))\n \nasync def main():\n    # Vytvoření více tasků\n    tasks = []\n    for i in range(5):\n        tasks.append(asyncio.create_task(download_file(i)))\n    await asyncio.gather(*tasks)\n \nasyncio.run(main()) #hlavní Event-Loop```"},"codes/codes/synchronization_tools/multiprocessing_pool.py":{"title":"multiprocessing_pool.py","links":[],"tags":[],"content":"from multiprocessing import Pool\n \n# Funkce pro výpočet mocniny dvěma\ndef do_something(x):\n    return x * x\n \n# Vytvoříme pool, kterému předáme kolekci dat a funkci kterou paralelně provede na všechny prvky\ndef pool_run():\n    data = [1,2,3,4,5]\n    pool = Pool(processes=4)\n \n    result = pool.map(do_something, data)\n    print(result)\n \nif __name__ == &quot;__main__&quot;:\n    pool_run()```"},"codes/codes/synchronization_tools/multiprocessing_process.py":{"title":"multiprocessing_process.py","links":[],"tags":[],"content":"from multiprocessing import Process\nimport time, random\n \ndef process_function(process_id):\n    print(&quot;Proces {} začal práci.&quot;.format(process_id))\n    time.sleep(random.randint(1, 5))\n    print(&quot;Proces {} dokončil práci.&quot;.format(process_id))\n \ndef process_run():\n    processes = []\n    for i in range(5):\n        p = Process(target=process_function, args=(i,))\n        processes.append(p)\n        p.start()\n \n    for p in processes:\n        p.join()\n    print(&quot;Všechny procesy dokončili práci&quot;)\n \nif __name__ == &quot;__main__&quot;:\n    process_run()```"},"codes/codes/synchronization_tools/multiprocessing_qpipe.py":{"title":"multiprocessing_qpipe.py","links":[],"tags":[],"content":"import multiprocessing\nfrom multiprocessing import Process, Queue\n \ndef producer(conn,q):\n    q.put(&quot;Queue Message&quot;)\n    conn.send(&quot;Pipe Message&quot;)\n    conn.close()\n \ndef consumer(conn,q):\n    msg = q.get()\n    print(msg)\n    msg = conn.recv()\n    print(msg)\n    conn.close()\n \ndef process_run():\n    q = multiprocessing.Queue()\n    conn1, conn2 = multiprocessing.Pipe()\n \n    p1 = Process(target=producer, args=(conn1,q,))\n    p2 = Process(target=consumer, args=(conn2,q,))\n    p1.start()\n    p2.start()\n \nif __name__ == &quot;__main__&quot;:\n    process_run()```"},"codes/codes/synchronization_tools/multiprocessing_valarray.py":{"title":"multiprocessing_valarray.py","links":[],"tags":[],"content":"from multiprocessing import Process, Value, Array\n \n# Funkce vypočítá mocniny dvou v poli a udělá součet všech hodnot.\ndef process_function(data,sum,squares):\n    for i, num in enumerate(data):\n        squares[i] = num * num\n        sum.value += squares[i]\n \ndef process_run():\n    data = [1,2,3,4]\n \n    # Vytvoříme objekty pro sdílení proměnných mezi procesy\n    sum = Value(&#039;i&#039;, 0)\n    squares = Array(&#039;i&#039;, 4)\n \n    p = Process(target=process_function, args=(data,sum,squares,))\n    p.start()\n \n    p.join()\n    print(&quot;Squares: {}&quot;.format(squares[:]))\n    print(&quot;Sum: {}&quot;.format(sum.value))\n \nif __name__ == &quot;__main__&quot;:\n    process_run()```"},"codes/codes/synchronization_tools/threading_barrier.py":{"title":"threading_barrier.py","links":[],"tags":[],"content":"import threading, time\n \n# Vytvoříme bariéru, určíme kolik vláken k ní musí dojít, než je propustí.\nbarrier = threading.Barrier(3)\n \n# Vlákno vykonává práci a následně čeká než tu stejnou práci nedokončí ostatní vlákna.\n# Pak vlákna pokračují vykonáváním další práce.\ndef thread_function(thread_id):\n    print(&quot;Vlákno {} vykonává 1. fázi&quot;.format(thread_id))\n    time.sleep(2)\n \n    print(&quot;Vlákno {} čeká u bariéry.&quot;.format(thread_id))\n    barrier.wait()\n \n    print(&quot;Vlákno {} vykonává 2. fázi&quot;.format(thread_id))\n    time.sleep(2)\n \ndef thread_run():\n    threads = []\n    for i in range(3):\n        thread = threading.Thread(target=thread_function, args=(i,))\n        threads.append(thread)\n        thread.start()\n \n    for thread in threads:\n        thread.join()\n    print(&quot;Všechna vlákna dokončila práci.&quot;)\n \nthread_run()```"},"codes/codes/synchronization_tools/threading_condition.py":{"title":"threading_condition.py","links":[],"tags":[],"content":"import threading, time\n \ncond = threading.Condition()\n \n# Konzumer bude čekat na splnění podmínky producenta\ndef consumer(id):\n    with cond:\n        cond.wait()\n        print(&quot;Konzumer {} obdržel zprávu.&quot;.format(id))\n \n# Producent udělá práci a oznámi dokončení některému z konzumentů\ndef producer():\n    time.sleep(2)\n    for i in range(5):\n        with cond:\n            print(&quot;Producent vyprodukoval zprávu.&quot;)\n            cond.notify()\n            time.sleep(2)\n \ndef thread_run():\n    threads = []\n    prod_thread = threading.Thread(target=producer)\n    prod_thread.start()\n    for i in range(5):\n        cons_thread = threading.Thread(target=consumer, args=(i,))\n        threads.append(cons_thread)\n        cons_thread.start()\n \n    prod_thread.join()\n    for cons_thread in threads:\n        cons_thread.join()\n    print(&quot;Vlákna dokončila práci.&quot;)\n \nthread_run()```"},"codes/codes/synchronization_tools/threading_event.py":{"title":"threading_event.py","links":[],"tags":[],"content":"import threading, time\n \nevent = threading.Event()\n \n# První vlákno bude čekat než je podmínka splněna\ndef wait_function():\n    print(&quot;Vlákno 1 čeká na splnění podmínky.&quot;)\n    event.wait()\n    print(&quot;Vlákno 1 obdrželo signál o splnění podmínky.&quot;)\n \n# Druhé vlákno chvíly pracuje a následně nastaví event na True\ndef signal_function():\n    time.sleep(2)\n    event.set()\n    print(&quot;Vlákno 2 splnilo podmínku.&quot;)\n \ndef thread_run():\n    thread1 = threading.Thread(target=wait_function)\n    thread2 = threading.Thread(target=signal_function)\n \n    thread1.start()\n    thread2.start()\n \n    thread1.join()\n    thread2.join()\n    print(&quot;Vlákna dokončila práci.&quot;)\n \nthread_run()```"},"codes/codes/synchronization_tools/threading_lock.py":{"title":"threading_lock.py","links":[],"tags":[],"content":"import threading\n \n# Definice zámku a globální proměnné pro počítadlo.\nlock = threading.Lock()\ncount = 0\n \n# Vlákno pro čítač.\n# Zamkneme blok kódu, který přistupuje ke sdlílené proměnné.\ndef counter():\n    with lock:\n        global count\n        count = count + 1\n        print(count)\n \ndef thread_run():\n    threads = []\n    for i in range(5):\n        thread = threading.Thread(target=counter)\n        threads.append(thread)\n        thread.start()\n \n    for thread in threads:\n        thread.join()\n \nthread_run()```"},"codes/codes/synchronization_tools/threading_semaphore.py":{"title":"threading_semaphore.py","links":[],"tags":[],"content":"import threading, time\n \n# Vytvoříme semafor, určíme max počet přístupů.\nsem = threading.Semaphore(3)\n \n# Vlákno pro práci se zdrojem, zkontrolujeme semafor.\n# Pokud může, přistoupí ke zdroji.\n# Pokud ne, čeká.\ndef resource(thread_id):\n    print(&quot;Vlákno {} čeká na přístup ke zdroji.&quot;.format(thread_id))\n    with sem:\n        print(&quot;Vlákno {} přístoupilo ke zdroji.&quot;.format(thread_id))\n        time.sleep(2);\n \n    print(&quot;Vlákno {} dokončilo práci se zdrojem.&quot;.format(thread_id))\n \ndef thread_run():\n    threads = []\n    for i in range(5):\n        thread = threading.Thread(target=resource, args=(i,))\n        threads.append(thread)\n        thread.start()\n \n    for thread in threads:\n        thread.join()\n    print(&quot;Všechna vlákna dokončila práci.&quot;)\n \nthread_run()```"},"codes/codes/synchronization_tools/threading_thread.py":{"title":"threading_thread.py","links":[],"tags":[],"content":"import threading, time, random\n \n# Vlákno pro práci. Uspíme na náhodný čas pro simulaci práce.\ndef thread_function(thread_id):\n    print(&quot;Vlákno {} začalo práci.&quot;.format(thread_id))\n    time.sleep(random.randint(1, 5))\n    print(&quot;Vlákno {} dokončilo práci.&quot;.format(thread_id))\n \ndef thread_run():\n    threads = []\n    for thread_id in range(1, 5):\n        thread = threading.Thread(target=thread_function, args=(thread_id,))\n        threads.append(thread)\n        thread.start()\n \n    for thread in threads:\n        thread.join()\n    print(&quot;Všechny vlákna dokončili práci.&quot;)\n \nthread_run()```"},"index":{"title":"PDS 2024 - Python Web Handout","links":["uvod_do_paralelizace","synchronizacni_nastroje_std_knihovny","problemy_jazyka_python_a_externi_nastroje","rabbitmq","socket_http","codes/synchronization_tools/","codes/external_tools/","codes/rabbitmq_examples/","codes/socket_http/"],"tags":[],"content":"Vítejte na úvodní stránce handoutu, který vám poskytne základy a praktické ukázky pro pochopení paralelního programování a distribuovaných systémů s využitím jazyka Python. Tento materiál je rozdělen do několika tématických částí, které vás postupně provedou od teoretického úvodu až po pokročilejší použití externích nástrojů a technologií.\n\nObsah\n\n\nÚvod do paralelizace v Pythonu\nZákladní pojmy, motivace a přehled konceptů paralelního výpočtu. Proč a kdy tyto přístupy používat?\n\n\nSynchronizační nástroje standardní knihovny Pythonu\nPředstavení nástrojů jako threading, multiprocessing a dalších, které Python nabízí pro práci s paralelními úlohami. Jak zvládat synchronizaci a předcházet problémům?\n\n\nProblémy Pythonu a externí nástroje\nOmezení Pythonu při paralelním zpracování (GIL, výkon) a jak je řešit. Představení knihoven a nástrojů jako Celery, Dask, nebo Ray.\n\n\nPráce s RabbitMQ\nPoužití RabbitMQ pro realizaci distribuovaných úloh. Základy front zpráv, výhody použití a praktická implementace v Pythonu.\n\n\nKomunikace pomocí soketů a HTTP\nImplementace komunikace mezi procesy nebo systémy pomocí soketů a protokolu HTTP. Základy práce se standardními knihovnami Pythonu pro tyto účely.\n\n\n\nUkázkové kódy\nVšechny ukázky uvedené v handoutu si můžete prohlédnout a spustit. Kódy jsou uspořádány ve složce codes, která je rozdělena podle kapitol:\n\nKapitola 2: Synchronizační nástroje (threading a multiprocessing)\nKapitola 3: Ukázky s externími nástroji (Dask, Celery, Ray)\nKapitola 4: RabbitMQ - Implementace front zpráv\nKapitola 5: Sokety a HTTP - Komunikace mezi procesy\n\nKaždý adresář obsahuje README s krátkým popisem kódů a instrukce k jejich spuštění.\n\nDoporučení k práci s handoutem\nKaždá sekce obsahuje teoretický úvod i praktické ukázky, které si můžete vyzkoušet. Pro lepší pochopení doporučujeme pracovat s obsahem sekvenčně a zkoušet ukázkové kódy na vlastním počítači. Pokud narazíte na problém, doporučujeme se vrátit k teoretické části dané kapitoly.\n\nDalší kroky\nZačněte prvním tématem: Úvod do paralelního programování a distribuovaných systémů. Pokud máte nějaké dotazy nebo problémy, neváhejte se obrátit na contributory tohoto repozitáře."},"problemy_jazyka_python_a_externi_nastroje":{"title":"Problémy jazyka Python a externí nástroje","links":[],"tags":[],"content":"Problémy jazyka Python\n\nÚčelem paralelizace je maximalizovat použití výpočetních zdrojů, nejde tím ale Python trochu naproti?\n\nPython je znám pro svou nevýkonnost\n\ndynamický jazyk - spoustu režie za běhu programu (GC, typová kontrola…)\n\n\nOmezení GIL - jedno vlákno na jeden proces (dnes již volitelný)\npoužití více vláken pro výpočet náročné na CPU nepřináší žádné výrazné zrychlení (pokud nějaké)\n\n\nVlákna mají v Pythonu ale stále využití, pokud čekají často na externí události (čtení/zápis, databáze, obsluha klienta…)\n\nFramework asyncio\n\nposkytuje základ pro tvorbu a správu síťové komunikace, webové servery, práci s databází, fronty\n\n\naiohttp\n\nknihovna založená na asyncio používaná pro asynchronní HTTP požadavky\n\n\n\n\n\nŘešení výkonnosti a paralelizace v Pythonu\n\nExistuje řada přístupů, jak obejít omezení GIL a celkově zrychlit výpočet\n\nPoužití knihovny multiprocessing\n\nPřed verzí CPython 3.13 se dalo opravdové paralelizace dosáhnout pouze vytvářením nových procesů\nTvorba a správa procesů však je obecně dražší a náročnější (nesdílejí paměť) než u vláken\n\nPoužití jiných implementací Pythonu\n\nExistují jiné implementace Pythonu, které se mírně odchylují od standardní implementace (CPython)\nNěkteré implementují techniky, které mohou běh programu za jistých okolností zrychlit\n\nJIT kompilace\n\nDynamicky kompiluje často používané části kódu do strojového kódu, který se za běhu programu dále optimalizuje\nVýhodné obzvláště pro dlouhotrvající procesy\nPříklady:\n\nNumba - optimalizován pro číselné operace\n\nvyužívá NumPy a jeho struktur\nnení potřeba v kódu provádět žádné výrazné změny\npříslušně označený kód se zkompiluje do strojového kódu, rychlost pak může být porovnatelný s kódem psaný v C či C++\nnejvíce při práci s čísly, poli a NumPy funkcemi\nmožnost paralelizace operací, které nevyžadují Python interpret\n\n(nepřestupují ke specifickým objektům Pythonu)\n\n\n\n\nPyPy (Python in Python)\nJyphon - implementace v Javě - bez GIL\n\npřeklad do mezikódu, který je následně vykonáván v JVM\nmožné integrovat kód v Pythonu do aplikací v Javě\n\n\nIronPython - obdoba Jyphon pro .NET - bez GIL\n\nCLR\n\n\n\n\nPříklad Numba\n\n# Převzato z numba.readthedocs.io/en/stable/user/5minguide.html\n \nfrom numba import jit\nimport numpy as np\n \n# Posloupnost 0...99 je převedena na tvar matice 10x10 [[0...9], [10...19]...[90...99]]\nx = np.arange(100).reshape(10, 10)\n \n# Pouhé přidání dekorátoru &quot;@numba.jit&quot; při jeho prvním zavolání zajistí kompilaci funkce do strojového kódu\n@jit\ndef go_fast(a):\n    trace = 0.0\n    for i in range(a.shape[0]):\n\t\ttrace += np.tanh(a[i, i])  # Použití funkcí NumPy\n    return a + trace               # Přičtení &quot;trace&quot; ke každému prvku matice\nprint(go_fast(x))\n \n \n@jit(nopython=True, parallel=True) \ndef parallel_sum(arr): \n\ttotal = 0 \n\tfor i in prange(len(arr)):  # speciální konstrukt umožňující paralelní vykonání\n\t\ttotal += arr[i] \n\treturn total\nStatická kompilace do nižšího jazyka\n\nKompilace kódu v Python do sdílené knihovny v C nebo C++ (v podobě &#039;.so&#039; nebo  .dll), který lze přímo volat v Pythonu\nPříklady jsou: Cyphon, mypyc…\n\nrozšiřují syntaxi o typové notace, které umožňují optimalizaci kompilovaného kódu\n\n\nCyphon\n\numožňuje také volat funkce existujících knihoven C/C++\nV souboru .pyx zapisujeme kód v Pythonu, které se následně zkompiluje do C/C++\n\n\n\n# Explicitní typování\ncdef int x = 10\n \n# Použití funkce z externí knihovny C\ncdef extern from &quot;math.h&quot;:\n\tdouble sqrt(double x)\n \ndef calc_square_root(double x):\n\treturn sqrt(x)\n \n# Paralelizace bez GIL\nfrom cython.parallel import prange\ndef parallel_sum(int n):\n\tcdef int i, total = 0\n\twith nogil:\n\t\tfor i in prange(n, nogil=True):\n\t\t\ttotal += i return total\n\nMyPyc\n\nvyužívá statické typování MyPy\n\n\n\n# mathlib.py\ndef multiply(x: int, y: int) -&gt; int:\n    return x * y\n \n# příkazem &quot;mypyc --strict mathlib.py&quot; se vytvoří &quot;C extension&quot;, který lze v Pythonu importotvat jako běžný modul\n \n# main.py\nimport mathlib as m\nprint(m.add(4, 20)) \n \nExterní knihovny psané v nízkoúrovňových jazycích\n\nPředevším v C a C++\nOptimalizované pro úlohy náročné na procesor\n\npředevším zpracovávání velkých číselných dat\n\n\nPython pak slouží spíše jako jakási řídící vrstva, která deleguje náročné výpočty externím modulům implementovaných v nižších jazycích\nZpracování v jiném jazyce nejsou limitovány GIL\n\nNepoužívat Python\n\nPožadujeme-li aplikace náročný výpočet na procesoru, měli bychom spíše zvolit jiný jazyk\n\nExterní nástroje využívající paralelizaci\n\nExistují knihovny, které ke složitým výpočtům na velkých datech využívají paralelizaci\n\nDask\n\nKnihovna navržena pro paralelizaci při zpracovávání velkých dat, ale i pro distribuované výpočty (clustery)\nUmožňuje pracovat s daty, které překračují velikost dostupné paměti - “out-of-core computing”\nVlastnosti:\n\nPlánování úloh (tasks)\n\núlohu rozděluje do menších částí a sestavuje graf závislostí, podle kterého se následně řídí výpočet\nX → Y → Z\nY → W\nPřed vykonáním Z musí být vykonán Y, přičemž W může běžet souběžně se Z\n\n\nSpráva grafu úloh\n\nDask před samotným výpočtem provádí analýzu a optimalizaci grafu\n\n\nLíné vyhodnocování\n\nvýpočet není výkonán ihned, ale je vložen do grafu úloh\n\n\n\n\nVykonávání plánovaných úloh lze realizovat pomocí:\n\nThreadedScheduler\n\nvyužívá vláken v Pythonu pro paralelní vykonávání úloh\nvhodný pro úlohy čekající na I/O\n\n\nMultiprocessingScheduler\n\npro parelelní běh jsou vyhrazeny samostatné procesy\n\n\nDistributedScheduler\n\nvykonávání napříč stroji či clustery\n\n\n\n\nVyužívá knihoven jako NumPy, Pandas či jiných pro rychlejší nízkoúrovňové výpočty\n\nimport dask.array as dusky\n \n# Naivní příklad paralelizace...\n \n# Vytvoří matici 10000x10000, ta je rozdělena na části 1000x1000 (chunks), které se zpracují nezávisle na sobě\nx = dusky.random.random((10000, 10000), chunks=(1000, 1000))\ny = x + x.T\n \nresult = y.sum().compute()\n \n# Líné vyhodnocování, odkladání výpočtu\n \n@dask.delayed\ndef inc(x):\n   return x + 1\n \n@dask.delayed\ndef add(x, y):\n   return x + y\n \na = inc(1)       # nic nevykoná\nb = inc(2)       # nic nevykoná\nc = add(a, b)    # nic nevykoná\n \nc = c.compute()  # Vykoná všechny výpočty výše\nDalší…\n\nRay, Celery\n"},"rabbitmq":{"title":"Práce s RabbitMQ","links":[],"tags":[],"content":"Co je RabbitMQ?\nRabbitMQ je message broker implementující protokol AMQP (Advanced Message Queuing Protocol). Umožňuje komunikaci mezi aplikacemi nebo jejich komponentami. RabbitMQ umožňuje oddělení producentů a konzumentů, což podporuje asynchronní komunikaci.\nHlavní pojmy\n\nMessage Broker: Implementuje systém front zpráv.\nExchanges (výměníky): Komponenty odpovědné za směrování zpráv do správných front.\nBinding: Spojení mezi výměníkem a frontou, identifikován pomocí binding key.\nRouting key: Identifikace jednotlivých zpráv.\n\nPříklad: Posílání zprávy (producent)\nimport pika\n \n# Navázání spojení s RabbitMQ serverem\nconnection = pika.BlockingConnection(pika.ConnectionParameters(&#039;localhost&#039;))\nchannel = connection.channel()\n \n# Deklarace fronty\nchannel.queue_declare(queue=&#039;hello&#039;)\n \n# Odeslání zprávy\nchannel.basic_publish(exchange=&#039;&#039;,\n                      routing_key=&#039;hello&#039;,\n                      body=&#039;Hello, RabbitMQ!&#039;)\n \nprint(&quot; [x] Zpráva &#039;Hello, RabbitMQ!&#039; byla odeslána.&quot;)\n \n# Uzavření spojení\nconnection.close()\nPříklad: Příjem zprávy (konzument)\nimport pika\n \ndef callback(ch, method, properties, body):\n    print(f&quot; [x] Přijatá zpráva: {body}&quot;)\n \n# Navázání spojení s RabbitMQ serverem\nconnection = pika.BlockingConnection(pika.ConnectionParameters(&#039;localhost&#039;))\nchannel = connection.channel()\n \n# Deklarace fronty\nchannel.queue_declare(queue=&#039;hello&#039;)\n \n# Přihlášení ke zprávám z fronty\nchannel.basic_consume(queue=&#039;hello&#039;, on_message_callback=callback, auto_ack=True)\n \nprint(&#039; [*] Čekám na zprávy. Pro ukončení stiskněte CTRL+C&#039;)\nchannel.start_consuming()\nVýhody RabbitMQ\nMezi hlavní výhody RabbitMQ patří:\n\nOddělení (decoupling): Producenti nemusí čekat na zpracování zpráv, což umožňuje asynchronní provádění úloh.\nŠkálování: RabbitMQ usnadňuje přidávání nových producentů nebo konzumentů, což podporuje horizontální škálování.\nVýkon: Broker může běžet na samostatném zařízení, což zlepšuje výkon.\n\nTypy výměníků (Exchanges)\nVýměníky definují, jakým způsobem jsou zprávy směrovány do front:\n\nDirect: Směřuje zprávy do konkrétní fronty na základě kompletní shody binding key a routing key.\nFanout: Rozesílá všechny zprávy do všech front napojených na výměník.\nTopic: Směruje zprávy do front na základě částečné shody mezi binding key a routing key (pattern matching).\nHeader: Směruje zprávy podle hodnot v hlavičkách zpráv.\n\nPříklad: Implementace Fanout Exchange\nimport pika\n \n# Navázání spojení s RabbitMQ serverem\nconnection = pika.BlockingConnection(pika.ConnectionParameters(&#039;localhost&#039;))\nchannel = connection.channel()\n \n# Deklarace výměníku typu fanout\nchannel.exchange_declare(exchange=&#039;logs&#039;, exchange_type=&#039;fanout&#039;)\n \n# Deklarace fronty\nresult = channel.queue_declare(&#039;&#039;, exclusive=True)\nqueue_name = result.method.queue\n \n# Přiřazení fronty k výměníku\nchannel.queue_bind(exchange=&#039;logs&#039;, queue=queue_name)\n \n# Callback pro zpracování přijatých zpráv\ndef callback(ch, method, properties, body):\n    print(f&quot; [x] Přijatý log: {body}&quot;)\n \n# Přihlášení ke zprávám\nchannel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=True)\n \nprint(&#039; [*] Čekám na logy. Pro ukončení stiskněte CTRL+C&#039;)\nchannel.start_consuming()\nFunkce a vlastnosti\n\nSpolehlivost: Možnost zajištění, že se zprávy neztratí ani při výpadcích.\nFlexibilita: Podpora více protokolů, například AMQP, MQTT nebo STOMP.\nŠkálovatelnost: Jednoduché přidávání producentů, konzumentů nebo zvýšení výkonu systému.\nPluggability: Možnost snadného rozšíření funkcionality pomocí pluginů.\n\n\nPříklad: Spolehlivost zpráv\nimport pika\n \n# Navázání spojení s RabbitMQ serverem\nconnection = pika.BlockingConnection(pika.ConnectionParameters(&#039;localhost&#039;))\nchannel = connection.channel()\n \n# Deklarace fronty s povolením trvalosti (durable)\nchannel.queue_declare(queue=&#039;task_queue&#039;, durable=True)\n \n# Publikování zprávy s potvrzením\nchannel.basic_publish(exchange=&#039;&#039;,\n                      routing_key=&#039;task_queue&#039;,\n                      body=&#039;Úkol 1&#039;,\n                      properties=pika.BasicProperties(\n                          delivery_mode=2,  # Zpráva je trvalá\n                      ))\n \nprint(&quot; [x] Zpráva &#039;Úkol 1&#039; byla odeslána.&quot;)\n \n# Uzavření spojení\nconnection.close()\nVyužití RabbitMQ\nRabbitMQ nachází využití v různých scénářích:\n\nAsynchronní zpracování úloh: Oddělení umožňuje producentům odesílat úlohy bez čekání na jejich dokončení, což dovoluje zpracovávání úloh, které jsou časově náročné nebo nevyžadují okamžité zpracování.\nLoad balancing: Rozložení zátěže mezi více konzumentů.\nZpracování dat v reálném čase: Užitečné pro monitoring, logování a další.\n\nPříklad: Zpracování logů v reálném čase\nimport pika\n \n# Navázání spojení s RabbitMQ serverem\nconnection = pika.BlockingConnection(pika.ConnectionParameters(&#039;localhost&#039;))\nchannel = connection.channel()\n \n# Deklarace výměníku typu fanout pro logy\nchannel.exchange_declare(exchange=&#039;logs&#039;, exchange_type=&#039;fanout&#039;)\n \n# Deklarace fronty pro příjem logů\nresult = channel.queue_declare(&#039;&#039;, exclusive=True)\nqueue_name = result.method.queue\n \n# Přiřazení fronty k výměníku\nchannel.queue_bind(exchange=&#039;logs&#039;, queue=queue_name)\n \n# Callback pro zpracování logů\ndef callback(ch, method, properties, body):\n    print(f&quot; [x] Přijatý log: {body}&quot;)\n \n# Přihlášení ke zprávám\nchannel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=True)\n \nprint(&#039; [*] Čekám na logy. Pro ukončení stiskněte CTRL+C&#039;)\nchannel.start_consuming()"},"socket_http":{"title":"Komunikace pomocí soketů a HTTP","links":[],"tags":[],"content":"Modul socket\n\ndocs.python.org/3/library/socket.html\nModul socket je základní nástroj pro implementaci síťové komunikace.\nJe nízkoúrovňový - jsou na něm založeny všechny ostatní moduly Pythonu vyšší úrovně pro propojení v síti.\nPodporuje většinu běžných protokolů, včetně TCP a UDP.\nData nejčastěji odesílány a přijímány jako bloky binárních dat.\n\nJe třeba určit jejich formu.\nNabízí se modul pickle - jedná se o modul v Pythonu, který  umožňuje převádět objekty do binárního formátu (serializace) a zpět (deserializace), což je užitečné pro ukládání dat nebo jejich přenos po síti.\n\n\n\nVytváření socketů:\nimport socket\n \nsocket = socket.socket(\n\tfamily=AF_INET,\n\ttype=SOCK_STREAM\n)\nPři vytváření socketů specifikujeme protokoly, které bude socket používat. Dva základní parametry: family a type.\nfamily - určuje, jaký protokol na síťové vrstvě bude socket používat.\n\nsocket.AF_INET: Pro IPv4 adresy.\nsocket.AF_INET6: Pro IPv6 adresy.\nsocket.AF_UNIX: Unixový socket (pro lokální komunikaci mezi procesy).\nsocket.AF_NETLINK\n\ntype - určuje, jaký styl komunikace socket podporuje.\n\nsocket.SOCK_STREAM:\n\nPoužívá TCP (spolehlivý, orientovaný na připojení, přenos dat jako proud bajtů).\n\n\nsocket.SOCK_DGRAM:\n\nPoužívá UDP (nespolehlivý, bez připojení, přenos dat jako jednotlivé pakety).\n\n\nsocket.SOCK_RAW\n\n\n\n                  \n                  Výchozí hodnoty family je socket.AF_INET a pro parametr type socket.SOCK_STREAM.\n                  \n                \nVýchozí hodnota při vytváření socketu pro parametr \n\nOdeslání zprávy:\ns.connect((&#039;localhost&#039;, 12345)) # navázání spojení\ns.sendall(b&#039;Ahoj!&#039;) #odešle všechna data\ns.close() # ukončí socket s\nPři odesílání zprávy musíme znát adresu příjemce. Ta je určena dvojicí (host, port):\n\nhost je adresa příjemce na síťové vrstvě - ta je daná podle zvolené family\n\nPro simulaci na lokálním počítači lze využít localhost\n\n\nport je to číslo v rozsahu 1–65535, které specifikuje konkrétní aplikaci nebo službu na zařízení příjemce.\n\nNásledně data pošleme pomocí socket.send(), nebo socket.sendall()\n\nsendall - když se data nevlezou do bufferu, automaticky je rozdělí a pošle\nsend - pokud nemůže odeslat všechna data najednou (např. kvůli omezení bufferu), odešle jen část dat → Ruční řízení odesílání.\n\nPoslouchání a přijímání dat:\naddr = (&#039;localhost&#039;, 12345) # adresa na které posloucháme\ns.bind(addr) # přiřadí socket k adrese\ns.listen() # umožňuje přijímat příchozí připojení\nconn, addr = s.accept() # čeká se na příchozí připojení\nprint(f&#039;Připojeno: {addr}&#039;)\ndata = conn.recv(1024) #přijme data, max. 1024B\nconn.sendall(b&#039;Ahoj!&#039;) # pošle odpověď\nconn.close() # ukončí socket conn\ns.close() # ukončí socket s\nPro příjem zpráv je nutné přiřadit socketu adresu, na kterou můžou odesílatelé zasílat zprávy. Toho dosáhneme pomocí příkazu socket.bind(addr). Následně socket přepneme do tzv. poslouchacího módu pomocí socket.listen(). Pak můžeme čekat než obdržíme zprávu přes socket.accept(). socket.accept() po obdržení dat vrátí socket conn určený pro komunikaci s odesílatelem a adresu odesílatele addr. Samotnou zprávu pak dostaneme zadáním socket.recv(buffer_size). Parametr buffer_size udává maximální počet bajtů, které se mají přečíst při jednom volání metody.\n\nCo když data přesáhnou 1024B?\n\nPřijímací strana tohle nemá šanci zjistit.\nŘešení: Použití ukončovacího znaku, první zpráva nese informaci kolik bytů má přijímací strana čekat…\n\n\n\nVýhody:\n\nPřímá kontrola nad socketovou komunikací.\nFlexibilita pro implementaci vlastních protokolů.\n\nNevýhody:\n\nVyžaduje znalosti síťových protokolů.\nImplementace složitější logiky (např. HTTPS) je náročnější.\n\n\nModul http\n\ndocs.python.org/3/library/http.html\nModul http v Pythonu poskytuje nástroje pro práci s protokolem HTTP.\nJe rozdělen na několik podmodulů:\n\nhttp.client\nhttp.server\nhttp.cookies\nhttp.cookiejar\nhttp.HTTPStatus, http.HTTPMethod\n\n\nVyužívá ho mnoho vyšších knihoven, jako je requests nebo flask.\n\nVýhody:\n\nVyšší úroveň abstrakce.\nSnazší implementace běžných HTTP funkcionalit.\n\nNevýhody:\n\nOmezená flexibilita ve srovnání s nízkoúrovňovou komunikací pomocí socket.\n\nhttp.server\n\nTento modul definuje třídy pro implementaci HTTP serverů.\n\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\n \n \nclass MyHandler(BaseHTTPRequestHandler):\n \n\t# Definujeme metodu pro zpracování GET požadavků\n\tdef do_GET(self):\n\t\tpass\n \nserver = HTTPServer((&quot;localhost&quot;, 8000), MyHandler)\nprint(&quot;Server bezi na portu 8000...&quot;)\nserver.serve_forever()\nDva typy:\n\nhttp.server.HTTPServer(args)\nhttp.server.ThreadingHTTPServer(args) identický předchozímu, používá však vlákna ke zpracování požadavků - použití vícenásobné dědičnosti ThreadingMixIn\nArgumenty args\n_server_address_ opět dvojice host a port\n_RequestHandlerClass_ - zpracovává příchozí HTTP požadavky (např. GET, POST) a definuje, jak server na tyto požadavky odpoví\n\nBaseHTTPRequestHandler - Základní třída pro implementaci vlastního chování HTTP serveru.\nSimpleHTTPRequestHandler - Automaticky obsluhuje GET a HEAD požadavky. Automaticky poskytuje statické soubory z určeného adresáře.\nCGIHTTPRequestHandler - Rozšířená třída, která kromě statických souborů podporuje CGI (Common Gateway Interface) skripty.\nMetoda serve_forever() spustí server, aby neustále naslouchal na příchozí HTTP požadavky a obsluhoval je. Tento proces běží, dokud server není ukončen.\n\n\n\nUkázka metody pro zpracování GET\ndef do_GET(self):\n\t# Odeslání odpovědi s kódem 200 (OK)\n\tself.send_response(200)\n\t# Nastavení hlavičky Content-Type pro HTML obsah\n\tself.send_header(&quot;Content-type&quot;, &quot;text/html&quot;) \n\tself.end_headers()\n\t# Odeslání těla odpovědi – text &quot;Hello, World!&quot;     \n\tself.wfile.write(b&quot;Hello, World!&quot;) \nPomocí metody send_response(status_code) server pošle stavový kód, který signalizuje výsledek požadavku.\nMetoda send_header(key, value):\n\nkey: Klíč hlavičky (string) – specifikuje název hlavičky.\nvalue: Hodnota hlavičky (string) – obsah hlavičky.\nPro nastavení více hlaviček stačí send_header zavolat vícekrát před zavoláním end_headers(). Které specifikaci hlaviček ukončí.\n\nPro odesílání těla HTTP odpovědi se zavolá wfile.write(content). Tato metoda vyžaduje binární data. Lze opět poslat více než jedno tělo zprávy opakovaným zasláním této metody.\n\nSouvisející moduly\n\nsocketserver\n\nNávrh kódu pro tvorbu serverů bývá často podobný - proto je často vhodnější použít tento vysokoúrovňový modul.\nStará se o všechny základní operace a nám už stačí přidat třídy obsluhující požadavky s metodou handle().\nŘeší za nás komunikaci tím, že obslouží požadavek každého připojení, ať už sériově nebo předáním každého požadavku jeho vlastnímu samostatnému vláknu, či procesu.\nVíce na docs.python.org/3/library/ssl.html.\n\n\nasyncore\n\nModul pro asynchronní I/O operace se sokety.\nVíce na docs.python.org/3.11/library/asyncore.html.\n\n\nasynchat\n\nTento modul je nadstavbou nad asyncore, která usnadňuje práci s protokoly, které se skládají z několika zpráv (např. textové protokoly nebo protokoly, které očekávají více fragmentů dat).\nVíce na docs.python.org/3.11/library/asynchat.html.\n\n\nssl\n\nModul pro přidání SSL/TLS šifrování do soketové komunikace.\nDefinuje třídu ssl.SSLSocket zděděná z socket.Socket.\nVíce na docs.python.org/3/library/ssl.html.\n\n\ntwisted - komplexní síťový framework třetí strany\n\nNabízí podporu pro širokou škálu síťových protokolů, jako jsou HTTP, SMTP, POP3, IMAP a další.\nVíce na www.twistedmatrix.com.\n\n\n"},"synchronizacni_nastroje_std_knihovny":{"title":"Synchronizační nástroje standardní knihovny Pythonu","links":[],"tags":[],"content":"Python, stejně jako ostatní programovací jazyky, nabízí ve své standardní knihovně řadu nástrojů pro synchronizaci mezi procesy a vlákny, což usnadňuje psaní paralelního kódu. Knihovna obsahuje dva základní moduly pro paralelizaci:\n\nthreading: pro paralelizaci pomocí vláken.\nmultiprocessing: pro pravý paralelizmus pomocí procesů.\n\nModuly obsahují různé nástroje pro synchronizaci jako jsou zámky, semafory, bariéry nebo mechanizmy pro sdílená data, což umožňuje vývojářům bezpečné spuštění paralelního kódu.\nModul Threading\nTento modul umožňuje vytvářet a spravovat jednoduchá vlákna v rámci jednoho procesu. Práce s vlákny má nízkou režii, takže jsou vhodná především pro operace, které často čekají na dokončení vstupně-výstupních úloh. Vzato jsou ale omezena Global Interpreter Lockem. GIL umožňuje, aby v daném okamžiku mohlo být vykonáváno pouze jedno vlákno, i když běží na vícejádrovém procesoru. Tohle omezení braní pravému paralelismu, což znamená, že vlákna nejsou vhodná pro výpočetně náročné úlohy.\nVlákna jsou tedy vhodná pro operace, kde závisí na rychlosti I/O operací:\n\nČtení/zápis do souboru.\nSíťové požadavky.\nGrafické uživatelské rozhraní.\n\nVlákna z modulu threading sdílí paměť v rámci jednoho procesu, což umožňuje snadnou komunikaci mezi nimi, ale zároveň se můžeme lehce dopustit chyby, při manipulaci se sdílenými daty.\nAbychom mohli pracovat s vlákny, musíme nejdřív modul importovat.\nimport threading\nKlíčové koncepty\nTřída Thread\nÚplným základem pro práci s vlákny je třída Thread. Každá instance této třídy reprezentuje jedno vlákno. Vlákno vykoná konkrétní funkce, kterou mu předáme při jeho vytvoření, spolu se předanými argumenty.\nVlákno se spouští metodou .start() a může běžet paralelně s hlavním programem.\nPokud je potřeba, aby hlavní proces počkal na dokončení vlákna, lze využít metody .join().\nt = threading.Thread(target=some_function, args=(some_arg,))\nt.start()\n# Nějaký kód\nt.join()\nDalší užitečné funkce:\n\nis_alive() - vrací True, pokud je vlákno stále aktivní. Pokud skončilo, vrací False.\ngetName() - vrací název vlákna.\nsetName() -  můžeme změnit název vlákna.\nlocal() - pro ukládání hodnot specifických pro konkrétní vlákna.\n\nTřída Lock\nZámek je synchronizační mechanismus, který brání souběžnému přístupu více vláken ke sdíleným zdrojům. Zajišťuje, že v daný okamžik může ke sdíleným prostředkům přistupovat pouze jedno vlákno, čímž zabraňuje možným konfliktům.\nFunkce acquire() se používá pro zamčení určitého bloku kódu. Pokud se jiné vlákno bude snažit dostat k zámku, zablokuje se, dokud nebude zámek uvolněn.\nFunkce release() se využívá pro odemčení zámku.\nV Pythonu je možnost využít příkazu with, který automaticky obalí kód těmito funkcemi, což zvyšuje čitelnost a jednoduchost kódu.\nlock = threading.Lock()\n \ndef function():\n\t# Nějaký kód\n\twith lock:  \n\t    # Další kód\nVarianta RLock:\nRLock řeší situace, kdy vlákno, které už drží zámek, potřebuje tento zámek získat znovu. To je užitečné především v rekurzivních funkcích využívající zámek, nebo při použití více zamykacích operací ve stejném vlákně.\nlock = threading.RLock()\ndef recursive_function():\n\twith lock:\n\t\t# Nějaký kód\n\t\trecursive_function()\nTřída Semaphore\nSemafor je synchronizační nástroj, který umožňuje řídit přístup k omezenému počtu sdílených zdrojů. Na rozdíl od zámku, který povoluje přístup pouze jednomu vláknu, semafor umožňuje přístup více vláknům současně.\nSemafor si udržuje interní počítadlo count, které určuje počet vláken, které mohou přistoupit ke zdroji. Při inicializaci semaforu se zadává maximální hodnota tohoto počítadla.\nFunkce acquire(), zjistí jestli hodnota count je 0. Pokud ano, vlákno se zablokuje, pokud ne, count se dekrementuje.\nFunkce release() inkrementuje počítadlo.\nStejně jako u zámku lze využít příkazu with.\nsem = threading.Semaphore(limit)\n \ndef function():\n\t# Nějaký kód\n\twith sem:\n\t\t# kritická sekce\nTřída Barrier\nBariéra se může využít tehdy, kdy je potřeba, aby všechna vlákna dosáhla určitého místa v programu předtím, než budou pokračovat. To znamená, že vlákna budou čekat na ostatní, dokud všechna nedosáhnou bariéry. Bariéry jsou vhodné, pokud vlákna pracují ve fázích. Program tedy čeká, až všechna vlákna dokončí jednu fázi, a teprve poté se může pokračovat do fáze další.\nPři vytváření bariéry se nastavuje počet vláken, na které se bude čekat.\nFunkce wait() zajistí, že vlákno bude zablokováno, dokud stanovený počet vláken nedosáhne bariéry.\nbarrier = threading.Barrier(limit)\n \ndef function():\n\t# Nějaký kód\n\tbarrier.wait()\n\t# Další kód\nTřída Event\nEvent je jednoduchý mechanizmus, který umožňuje vláknům spolu komunikovat. Event obsahuje interní příznak, který může nabývat hodnot True nebo False. Ostatní vlákna tak mohou čekat, až bude příznak nastaven, předtím než budou pokračovat v činnosti. Jinak řečeno, vlákna čekají než je konkrétní podmínka splněna.\nPro práci s Eventem používají tyto funkce:\n\nset() pro nastavení příznaku na True.\nclear() pro resetování příznaku na False.\nwait() zablokuje vlákno dokud není hodnota příznaku True.\n\nJe zde i možnost předat funkci wait() argument timeout, který umožňuje specifikovat maximální dobu. Pokud nebude příznak v tomto časovém limitu nastaven, metoda wait() se ukončí.\nevent = threading.Event()\n \ndef function1():\n\t# Nějaký kód\n\tevent.wait()\n\t# Další kód kód\n \ndef function2():\n\t# Nějaký kód\n\tevent.set()\n\t# Další kód kód\nTřída Condition\nNa závěr máme nástroj Condition, který funguje obdobně jako Event s menšími rozdíly. Třída je propojena se synchronizačním nástrojem Lock, který je s každou instancí implicitně spojen. Tento zámek funguje stejně jako ten ze třídy Lock.\nPro práci s Condition používáme funkce:\n\nwait() zablokuje vlákno dokud není splněna podmínka, nebo nevyprší čas předaný v argumentu timeout.\nnotify() pro odblokování jednoho čekajícího vlákna.\nnotify_all() pro odblokování všech čekajících vláken.\n\ncond = threading.Condition()\n \ndef function1():\n\twith cond:\n\t\t# Nějaký kód\n\t\tcond.wait()\n\t\t# Další kód kód\n \ndef function2():\n\twith cond:\n\t\t# Nějaký kód\n\t\tcond.notify()\n\t\t# Další kód kód\nModul Multiprocessing\nTento modul umožňuje využití pravého paralelismu vytvářením nezávislých procesů, každý s vlastním paměťovým prostorem. Na rozdíl od vláken z modulu threading, procesy nejsou omezeny limitacemi GIL. Procesy jsou vhodné především pro výpočetně náročnější úkoly, které mohou být spuštěny na více jádrech procesoru.\nVýhodou nezávislosti procesů je, že jejich paměťové prostory jsou oddělené. To snižuje rizika spojená s prací se sdílenými prostředky, ale vzato zvyšuje nároky na paměť. Modul ale poskytuje mnoho nástrojů pro bezpečnou komunikaci a sdílení zdrojů.\nKlíčové koncepty\nTřída Process\nÚplným základem modulu multiprocessing je třída Process, jejíž instance reprezentuje samotný proces. Tvorba procesu probíhá úplně stejně jako tvorba vláken. Tedy při tvorbě předáme funkci, kterou proces vykoná, společně s předaným argumentem. Proces se následně spustí metodou .start(). Hlavní proces může počkat na dokončení práce pomocí metody .join().\nfrom multiprocessing import Process\n \np = Process(target=some_function, args=(some_arg,))  \np.start()\n# Nějaký kód\np.join()\nNa procesy lze navíc volat metoda .terminate(), která vynutí ukončení běžícího procesu. Měla by se používat omezeně, jelikož může dojít k uvedení sdílených zdrojů do nekonzistentního stavu.\nUžitečné atributy procesu:\n\nname - vrací jméno procesu, lze nastavit při jeho vytváření.\npid - vrací id procesu, které přidělí operační systém.\ndaemon - vrací příznak, jestli je proces nastaven jako daemon. Daemon proces běží na pozadí a je automaticky ukončen, pokud rodičovský proces skončí.\nis_alive - vrací příznak zda proces ještě pracuje.\n\nTřída Pool\nTato třída umožňuje efektivní správu procesů. Automatizuje proces jejich vytváření a umožňuje rozdělení práce mezi různá jádra procesoru. Obvykle se používá při zpracování kolekcí dat, kde každému prvku kolekce přiřadí jeden proces, který na něj aplikuje určenou funkci. Výsledky jednotlivých procesů jsou následně zkombinovány do jednoho výstupu.\nPři vytváření poolu musíme předat informaci o tom, kolik procesů se využije. Následně zavoláme funkci .map(), která aplikuje zadanou funkci na každý prvek z kolekce dat. Výsledek se uloží do proměnné.\nfrom multiprocessing import Process, Pool\n \n# Řekneme Poolu s kolika procesy má pracovat\npool = Pool(processes=num_of_processes) \n \nresult = pool.map(some_function, iterable_data)\nSdílení dat\nPro sdílení dat mezi procesy se používají objekty Value a Array. Tyto objekty umožňují bezpečnou správu sdílené paměti mezi procesy.\n\nValue reprezentuje jednu sdílenou proměnnou.\nArray reprezentuje pole sdílených dat.\n\nKonstruktor těchto objektů požaduje datový typ (Např.: ‘i’ - integer, ‘f’ - float, ‘c’ - char) a hodnotu. Následně s objektem Array můžeme pracovat jako s polem a s value můžeme pracovat pomocí .value.\nJe vhodné dále využít vhodných synchronizačních nástrojů pro práci se sdílenými proměnnými.\nfrom multiprocessing import Process, Value, Array\n \n# Definice objektů\nvalue = Value(&#039;i&#039;, init_value)  \nresult = Array(&#039;i&#039;, size)\n \n# Funkce, která využívá objektů pro sdílení dat\ndef example_function(data,value,result):  \n    for i, num in range(5):  \n        result[i] = num * num  \n        value.value += num\nKomunikace mezi procesy\nMeziprocesová komunikace je další způsob, jak si procesy mohou vyměňovat data a koordinovat činnosti. Modul multiprocessing pro komunikaci poskytuje dva základní objekty Queue a Pipe.\nQueue je datová struktura typu First-In-First-Out (FIFO), která umožňuje procesům bezpečně odesílat a přijímat data. Libovolné množství procesů může sdílet jednu frontu, což zajišťuje efektivní komunikaci mezi nimi. Práce s frontou je intuitivní – prvky se přidávají na konec a odebírají z čela. To odpovídá principu běžné fronty.\nfrom multiprocessing import Process, Queue\n \n# Definice fronty\nqueue = Queue()\n \n# Funkce, která posílá zprávu ostatním procesům\ndef producer(queue): \n\twhile True:\n\t\tqueue.put(&quot;Message&quot;) \n \n# Funkce která čte zprávy od ostatních procesů\ndef consumer(queue): \n\twhile True:\n\t\tmessage = queue.get() \nPipe poskytuje obousměrný komunikační kanál mezi dvěma procesy. Lze je využívat obousměrně nebo jen jednosměrně. Práce s nimi je jednoduchá, ale nelze využít pro více než dva procesy.\nfrom multiprocessing import Process, Pipe\n \n# Definice Pipy\nconn1, conn2 = multiprocessing.Pipe()\n \n# Funkce, která pošle zprávu přes Pipe\ndef producer(conn1):\n    conn.send(&quot;Pipe Message&quot;)  \n    conn.close()\n \n# Funkce, která získa zprávu přes Pipe\ndef consumer(conn2)\n\tmsg = conn.recv()\n\tconn.close()\n \nSynchronizace\nModul obsahuje stejné synchronizační nástroje jako modul threading. Tedy nástroje Lock, Semaphore, Barrier, Event, Condition. Tyto nástroje fungují stejně jako v modulu threading, takže je znovu nemusíme vysvětlovat.\nPři použití těchto nástrojů v kontextu modulu multiprocessing je však důležité mít na paměti, že pracují s procesy místo vláken. To znamená, že synchronizační primitiva musí být schopna fungovat mezi oddělenými procesy. Modul multiprocessing tuto izolaci zajišťuje pomocí mechanismů meziprocesové komunikace (IPC) pomocí:\n\nSdílené paměti.\nPipe a Queue.\nSouborů nebo socketů.\n\nModul Asyncio\nTento modul poskytuje nástroje pro asynchronní programování v Pythonu. To umožňuje různým úkolům běžet nezávisle s možností mezi sebou přepínat, aby neblokovaly celý proces. Z toho důvodu je tento modul vhodný pro vstupně-výstupní operace jako čtení souborů, práce s databází nebo zpracování HTTP požadavků.\nV Pythonu, na rozdíl od vláken a procesů, asyncio umožňuje vytvořit úkoly, které sdílí stejné vlákno, a přepínají se mez sebou bez blokování tohoto vlákna. Proto jsou vhodné pro I/O operace, jelikož nemusíme zbytečně čekat na jejich dokončení.\nAbychom mohli pracovat s modulem, potřebujeme ho prvně importovat.\nimport asyncio\nKlíčové koncepty\nEvent Loop\nZákladním konceptem modulu je událostní smyčka (Event Loop). Ta je zodpovědná za plánování, koordinaci a správu asynchronních úloh. V Pythonu se smyčkou nepracuje přímo, ale využívá se funkcí.\nKe spuštění se využívá funkce .run(), které se předá korutina.\nasnycio.run(main())\nCoroutine\nKorutina je speciální typ asynchronní funkce, kterou máme možnost zastavit a znovu ji spustit později. To je velmi důležité pro asynchronní programování, kde se korutiny mohou vzdávat činnosti.\nFunkce se stane asynchronní pokud ji definujeme pomocí klíčového slova async. Korutina se může vzdát činnosti použitím klíčového slova await, což umožní dalším korutinám běh, mezitím co čekají na dokončení nějaké I/O operace.\nasync def coroutine(): \n\tdo_something()\n\t# Simulace nějaké I/O operace, na kterou je potřeba počkat\n\tawait asyncio.sleep(1) \n \nasyncio.run(coroutine())\nTask\nÚlohy umožňují obalit korutinu a naplánovat její běh v Event Loopu, a také umožňují spustit několik korutin paralelně. Úloha po spuštění běží na pozadí, a tak neblokují hlavní vlákno.\nBěhem toho co se úloha vykonává ve smyčce, můžeme sledovat její postup, zjistit výsledky nebo odchytávat výjimky. Úlohu vytvoříme pomocí funkce .create_task(), které se předá korutina jako argument.\ntask = asyncio.create_task(coroutine(arg))\nawait task\nMezitím co se úloha provádí, můžeme s ní pracovat pomocí různých vestavených metod.\n\n.result() vrátí výsledek úlohy po tom co je dokončena.\n.exception() umožňuje odchytit výjimku, kterou korutina vyvolala.\n.cancel() se pokusí zrušit vykonávání úlohy.\n\nPomocí funkce asnycio.gather() můžeme spustit několik úloh paralelně. Následně můžeme získat výsledky z jednotlivých úloh.\nresults = await asyncio.gather(task1, task2)\n# Nebo\nresults = await asyncio.gather(*tasks)\nDalším užitečným nástrojem je funkce .wait_for(), která umožňuje nastavit maximální čas čekání na dokončení nějaké I/O operace. Pokud při čekání na obsloužení nějaké I/O operace čekáme delší dobu, vyvolá se výjimka TimeoutError.\n# Korutina bude provádět čekání na dokončení operace déle než 3 sekundy\nasync def coroutine():\n\tawait asnycio.sleep(5)\n \ntry: \n\t# Nastavíme max dobu čekání 3 sekundy\n\tresult = await asyncio.wait_for(coroutine(), timeout=3)\nexcept asyncio.TimeoutError:\n\tprint(&quot;Timeout.&quot;)\nSynchronizace\nOpět jako v modulu threading a multiprocessing, i modul asyncio poskytuje stejné synchronizační nástroje jako je zámek, semafor, nebo třeba i frontu. Je zde i možnost využít klíčového slova async společně s with pro bezpečnější kód.\nsem = asyncio.Semaphore()\n \nasync with sem:\n\tawait asyncio.sleep(5)"},"uvod_do_paralelizace":{"title":"Úvod do paralelizace v Pythonu","links":[],"tags":[],"content":"1990: Počátky Pythonu a zaměření na jednoduchost\nPython byl vytvořen Guidem van Rossumem jako jazyk zaměřený na čitelnost a jednoduchost. První verze Pythonu z roku 1990 nepočítala s pokročilými nástroji pro paralelizaci, což bylo částečně dáno tím, že hardware v té době nebyl tak paralelizací posedlý jako dnes. Vývojáři se většinou spoléhali na jednovláknové aplikace, protože vícejádrové procesory a masivní paralelizace byly stále v plenkách. Tento důraz na jednoduchost ovlivnil mnoho rozhodnutí v návrhu Pythonu, včetně způsobu správy paměti, což se později stalo významným faktorem v omezení paralelizace.\n2000: Zavedení GIL (Global Interpreter Lock)\nRok 2000 přinesl vydání Python 2.0, které zavedlo několik klíčových funkcí, včetně automatického garbage collectoru založeného na počítání referencí. Tento přístup přinesl výhody, jako je snadné sledování a uvolňování nevyužívaných objektů. Nicméně tento systém není přirozeně thread-safe, což znamená, že pokud by více vláken manipulovalo s referenčním počítadlem současně, mohlo by dojít k problémům, jako jsou race conditions, úniky paměti nebo chybná dealokace objektů.\nAby se tyto problémy vyřešily, vývojáři Pythonu implementovali Global Interpreter Lock (GIL). Tento zámek zajišťuje, že v daném okamžiku může pouze jedno vlákno vykonávat Python kód v rámci interpretace. GIL chrání referenční počítání a další interní mechanismy Pythonu před konflikty mezi vlákny.\nPřestože GIL zjednodušil návrh a umožnil stabilní provoz v prostředí s více vlákny, přišel za cenu omezené paralelizace.\n\nEfektivní paralelizace na úrovní vláken je nemožná: Pouze jedno vlákno může aktivně vykonávat Python kód, i když je k dispozici více jader CPU. To znamená, že vlákna nezvyšují výkon při výpočetně náročných úlohách.\nI/O-bound aplikace stále profilují: GIL se uvolňuje při operacích, jako je čtení/zápis do souborů nebo sítě, což znamená, že více vláken může efektivně spravovat I/O-bound úlohy.\n\nZavedení GIL mělo dlouhodobé důsledky na to, jak je Python vnímán a používán. Nedávno Rada pro řízení vývoje Pythonu (Python Steering Council) oznámila svůj závěr schválit PEP 703, návrh na vytvoření verze Pythonu bez GIL. Tento krok má velký vliv na budoucí vývoj Pythonu. Od verze 3.13 je možné nainstalovat verzi Pythonu neobsahující GIL. Tato funkčnost ještě není dostupná v oficiálních verzích Pythonu a je potřeba ji doinstalovat:\napt install python3.13-full python3.13-nogil\nPoté je možno spustit Python bez GILu:\nPYTHON_GIL=0 python3.13-nogil test.py\n2008: Přidání knihovny multiprocessing pro paralelizaci pomocí procesů\nV roce 2008, s vydáním Pythonu 2.6 a 3.0, došlo k významnému kroku v možnosti paralelizace v Pythonu. Byl přidán modul multiprocessing. Tento krok měl zásadní význam, protože obcházel omezení GIL, který bránil efektivní paralelizaci na úrovni vláken.\nModul multiprocessing umožňuje programátorům vytvářet a spravovat samostatné procesy, které běží nezávisle na sobě, každý ve své vlastní paměťové oblasti. Na rozdíl od vláken, která sdílejí společnou paměť v rámci jednoho procesu, procesy běží ve svých vlastních prostorách a jsou vzájemně izolované. Tato izolace znamená, že každý proces si vytváří svůj vlastní Python interpreter, což znamená, že každý proces má vlastní GIL a vlastní prostor pro správu paměti. Tímto způsobem se vyhneme omezení GIL, které jinak brání paralelizaci na úrovni vláken. Každý proces může běžet na jiném CPU nebo jádru, což umožňuje efektivní využívání více jader procesoru a plně využít potenciál moderního vícejádrového hardwaru.\nDalší důležitá data k paralelizaci Pythonu\n\n2010 (Python 3.2): Python získal modul concurrent.futures, který poskytl jednodušší rozhraní pro práci s procesy a vlákny prostřednictvím Executor API. To umožnilo psát paralelní kód přehledněji a konzistentněji.\n2018 (Python 3.7): Modul asyncio byl stabilizován a stal se jedním z hlavních nástrojů pro asynchronní programování. Ačkoliv asyncio nespadá přímo pod paralelizaci, umožňuje efektivní správu vstupně-výstupních (I/O) operací, což je důležité pro moderní webové a síťové aplikace.\n"}}